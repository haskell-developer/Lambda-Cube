% Created 2020-03-01 Sun 21:23
% Intended LaTeX compiler: pdflatex
\documentclass[presentation]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage[linenos=true]{minted}
\usepackage{bussproofs}
\usepackage{xcolor}
\usemintedstyle{borland}
\usetheme{default}
\author{Solomon Bothwell}
\date{2020-03-02}
\title{Interpreting and Typechecking Simply Typed Lambda Calculus!}
\hypersetup{
 pdfauthor={Solomon Bothwell},
 pdftitle={Interpreting and Typechecking Simply Typed Lambda Calculus!},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.3 (Org mode 9.3.6)}, 
 pdflang={English}}
\begin{document}

\maketitle

\begin{frame}[label={sec:orgf05eaee}]{Untyped Lambda Calculus}
A formal system for expressing computation using function abstraction,
application, and reduction.
\end{frame}
\begin{frame}[label={sec:org2d78ad9}]{Syntax}
\begin{itemize}
\item Variables: \(x\)
\item Lambda Abstractions: \(\lambda x.x\)
\item Application: \(t_1 t_2\)
\end{itemize}
\end{frame}
\begin{frame}[label={sec:org51d1a4a}]{Reduction}
\begin{itemize}
\item Alpha Conversion (name changes)
\item Beta Reduction (applying functions to their arguments)
\item Eta Reduction (reducing abstraction around a function)
\end{itemize}
\end{frame}
\begin{frame}[label={sec:org30769f8}]{Example Terms}
\begin{itemize}
\item \(id := \lambda x.x\)
\item \(const := \lambda a.\lambda b.a\)
\item \(Z := \lambda f.\lambda x.x\)
\item \(S\,Z := \lambda f.\lambda x.f\,x\)
\item \(S\,S\,Z := \lambda f.\lambda x.f\,f\,x\)
\item \(True := \lambda p.\lambda q.p\)
\item \(False := \lambda p.\lambda q.q\)
\item \(Not := \lambda p.p\,False\,True\)
\item \(Or := \lambda p.\lambda q.p\,p\,q\)
\end{itemize}
\end{frame}
\begin{frame}[label={sec:orgcc8087b}]{Sample reduction}
\center{Not True} \\
\(\color{red}(\lambda p.p (\lambda p.\lambda q.q) (\lambda p.\lambda q.p))\,\color{blue}(\lambda p.\lambda q.p)\) \\
\(\color{red}(\lambda p.p (\lambda x.\lambda y.y) (\lambda f.\lambda g.f))\,\color{blue}(\lambda a.\lambda b.a)\) \\
\(\color{blue}(\lambda a.\lambda b.a) \color{red}(\lambda x.\lambda y.y)\,(\lambda f.\lambda g.f)\) \\
\(\color{blue}(\lambda b.\color{red}(\lambda x.\lambda y.y)\color{blue})\,\color{red}(\lambda f.\lambda g.f)\) \\
\(\color{red}\lambda x.\lambda y.y\)
\end{frame}
\begin{frame}[label={sec:org1446cf1}]{How powerful is this?}
Very powerful. Fully isomorphic to turning machines. 
\end{frame}
\begin{frame}[label={sec:org952350c}]{Evaluation Semantics}
\begin{block}{Operational Semantics - Intensional | How}
Create an abstract state machine consisting of terms as state and reduction
rules for terms which can be followed in sequence to reach some halting
state.
\end{block}
\begin{block}{Denotational Semantics - Extensional | What}
Create a mapping to a mathematical domain that denotes the meanings of terms.
\end{block}
\end{frame}
\begin{frame}[label={sec:orgff17274}]{Small Step/Big Step}
Operational Semantics comes in two flavors: 
\begin{itemize}
\item Small Step: describe individual steps of computation.
\item Big Step: describe the overall result of execution.
\end{itemize}
\end{frame}
\begin{frame}[label={sec:org92de9d3}]{Untyped Lambda Calculus}
\begin{columns}
\begin{column}[t]{0.4\columnwidth}
\begin{block}{Syntax}
\bigskip 
\begin{itemize}
\item[$t :=$] $x$
\item[] $\lambda x.t$
\item[] $t_1\,t_2$
\end{itemize}
\begin{itemize}
\item[$v :=$] $\lambda x.t$
\end{itemize}
\end{block}
\end{column}
\begin{column}[t]{0.6\columnwidth}
\begin{block}{Evaluation}
\begin{prooftree}
\RightLabel{E-App1}
\AxiomC{$ t_1 \to t_1' $}
\UnaryInfC{$ t_1 t_2 \to t_1' t_2 $}
\DisplayProof
\end{prooftree}

\begin{prooftree}
\RightLabel{E-App2}
\AxiomC{$ t_2 \to t_2' $}
\UnaryInfC{$ v_1 t_2 \to v_1 t_2' $}
\DisplayProof
\end{prooftree}

\((\lambda x . t_1_2)v_2 \to [x  \mapsto v_2]t_1_2\) E-AppAbs
\end{block}
\end{column}
\end{columns}
\end{frame}
\begin{frame}[label={sec:org4b38b26}]{Substitution Rules}
\begin{itemize}
\item \([x \mapsto s]x = s\)
\item \([x \mapsto s]y = y\)
\item \([x \mapsto s](\lambda y.t_1) = \lambda y. [x \mapsto s]t_1\)
\item \([x \mapsto s](t_1 t_2) = ([x \mapsto s]t_1)\,([x \mapsto s]t_2)\)
\end{itemize}
\end{frame}
\begin{frame}[label={sec:org41f86bf}]{Avoiding Name Collisions In Substitution}
\begin{block}{Given Expression:}
\color{red}\((\lambda.x\lambda y. (\lambda x.x)\,y\,x)\, \color{blue}(\lambda y.y\,(\lambda x.x))\)
\end{block}
\end{frame}
\begin{frame}[label={sec:org0013f10}]{Avoiding Name Collisions In Substitution}
\begin{block}{Given Expression:}
\color{red}\((\lambda x.\lambda y. (\lambda x.x)\,y\,x)\, \color{blue}(\lambda y.y\,(\lambda x.x))\)
\end{block}
\begin{block}{Evaluation Rule: E-AppAbs}
\color{red}\((\lambda x . t_1_2)\color{blue}v_2 \color{black}\to [x  \mapsto v_2]t_1_2\)
\end{block}
\end{frame}
\begin{frame}[label={sec:org60a8a60}]{Avoiding Name Collisions In Substitution}
\begin{block}{Given Expression:}
\color{red}\((\lambda x.\lambda y. (\lambda x.x)\,y\,x)\, \color{blue}(\lambda y.y\,(\lambda x.x))\)
\end{block}
\begin{block}{Evaluation Rule:}
\(E-AppAbs:\,\color{red}(\lambda x . t_1_2)\color{blue}v_2 \color{black}\to [x  \mapsto v_2]t_1_2\)
\end{block}
\begin{block}{Our substitution:}
\([x \mapsto \color{blue}(\lambda y.y\,(\lambda x.x))\color{black}]\color{red}(\lambda y. (\lambda x.x)\,y\,x)\)
\end{block}
\end{frame}
\begin{frame}[label={sec:orgb8e65eb}]{Avoiding Name Collisions In Substitution}
\begin{block}{Given Expression:}
\color{red}\((\lambda x.\lambda y. (\lambda x.x)\,y\,x)\, \color{blue}(\lambda y.y\,(\lambda x.x))\)
\end{block}
\begin{block}{Evaluation Rule:}
\(E-AppAbs:\,\color{red}(\lambda x . t_1_2)\color{blue}v_2 \color{black}\to [x  \mapsto v_2]t_1_2\)
\end{block}
\begin{block}{Our substitution:}
\([x \mapsto \color{blue}(\lambda y.y\,(\lambda x.x))\color{black}]\color{red}(\lambda y. (\lambda x.x)\,y\,x)\)
\end{block}
\begin{block}{Our Desired Final Value:}
\color{red}\((\lambda y. (\lambda x.x)\,y\,\color{blue}(\lambda y.y\,(\lambda x.x))\color{red})\)
\end{block}
\end{frame}
\begin{frame}[label={sec:org93c4eb2}]{Avoiding Name Collisions In Substitution}
\begin{block}{How do we perform this substitution without capturing free variables?}
\end{block}
\end{frame}
\begin{frame}[label={sec:org7e45ae5}]{Avoiding Name Collisions In Substitution}
\begin{block}{How do we perform this substitution without capturing free variables?}
\end{block}
\begin{block}{Two Options:}
\begin{enumerate}
\item Identify free variables and use Alpha Conversion prevent shadowing\\
\item Convert our Lambda Terms to Nameless Form using DeBruijn Indices.
\end{enumerate}
\end{block}
\end{frame}
\begin{frame}[label={sec:orgffb76d2}]{Avoiding Name Collisions In Substitution}
\begin{block}{Capture Avoiding Substitution}
\begin{enumerate}
\item Given the substitution \([\color{red}x  \color{black}\mapsto \color{blue}v_2\color{black}]\color{purple}t_1_2\)
\item Identiy all the bound variables in \(\color{purple}t_1_2\).
\item Rename all bound variables inside \(\color{purple}t_1_2\) with \emph{fresh} variables.
\item Perform the substitution of \(\color{blue}v_2\) for \(\color{red}x\) in \(\color{purple}t_1_2\).
\end{enumerate}
\end{block}
\begin{block}{Nameless Form (DeBruijn Indices)}
In nameless form variable names are replaced by natural numbers representing the
number of lambda abstractions between the variable and its binder.

Examples:
\begin{itemize}
\item \color{red}\(\lambda x.\color{blue}\lambda y.\color{red}x \color{black}\longrightarrow \color{red}\lambda\color{black}\color{blue}\lambda\color{black}\color{red}1\)
\item \color{red}\(\lambda x.\color{blue}\lambda y.\color{red}x \color{black}\longrightarrow \color{red}\lambda\color{black}\color{blue}\lambda\color{black}\color{blue}0\)
\item \color{red}\((\lambda x.\lambda y. (\lambda x.x)\,y\,x)\, \color{blue}(\lambda y.y\,(\lambda x.x)) \color{black}\longrightarrow \color{red}(\lambda\lambda(\lambda0)\,0\,1)\,\color{blue}(\lambda0(\lambda0))\)
\end{itemize}
\end{block}
\end{frame}
\begin{frame}[label={sec:org6b22a66},fragile]{A haskell implementation}
 \begin{minted}[,linenos=true, fontsize=\scriptsize]{haskell}
data Term = Var String 
          | Abs String Term 
          | App Term Term

singleEval :: Term -> Maybe Term
singleEval t =
  case t of
    (App (Abs x t12) v2) | isVal v2 -> Just $ subst x v2 t12
    (App v1@(Abs _ _) t2)           ->      App v1 <$> singleEval t2
    (App t1 t2)                     -> flip App t2 <$> singleEval t1
    _ -> Nothing

multiStepEval :: Term -> Term
multiStepEval t = maybe t multiStepEval (singleEval t)
\end{minted}
\end{frame}
\begin{frame}[label={sec:orgb00c120}]{Simply Typed Lambda Calculus}
\note{Notes
this is my note}
\begin{columns}
\begin{column}[t]{0.4\columnwidth}
\begin{block}{Syntax}
\scriptsize

\begin{itemize}
\item[$t :=$] $x$
\item[] $\lambda x:T.t$
\item[] $t_1\,t_2$
\end{itemize}

\begin{itemize}
\item[$v :=$] $\lambda x:T.t$
\end{itemize}

\begin{itemize}
\item[$T :=$] $T \to T$
\end{itemize}

\begin{itemize}
\item[$\Gamma :=$] $\varnothing$
\item[] $\Gamma,\,x:T$
\end{itemize}
\end{block}
\end{column}
\begin{column}[t]{0.6\columnwidth}
\begin{block}{Evaluation}
\vspace{-10pt}
\scriptsize
\begin{prooftree}
\RightLabel{E-App1}
\AxiomC{$ t_1 \to t_1' $}
\UnaryInfC{$ t_1 t_2 \to t_1' t_2 $}
\DisplayProof
\end{prooftree}

\begin{prooftree}
\RightLabel{E-App2}
\AxiomC{$ t_2 \to t_2' $}
\UnaryInfC{$ v_1 t_2 \to v_1 t_2' $}
\DisplayProof
\end{prooftree}

\((\lambda x : T_1_1 . t_1_2)v_2 \to [x  \mapsto v_2]t_1_2\) E-AppAbs
\end{block}
\begin{block}{Typing}
\vspace{-10pt}
\scriptsize
\begin{prooftree}
\RightLabel{T-Var}
\AxiomC{$ x : T\,\in\,\Gamma $}
\UnaryInfC{$ \Gamma \vdash x : T $}
\DisplayProof
\end{prooftree}

\begin{prooftree}
\RightLabel{T-Abs}
\AxiomC{$ \Gamma,x : T_1\,\vdash\,t_2:T_2 $}
\UnaryInfC{$ \Gamma \vdash \lambda x : T_1.t_2 : T_1 \to T_2 $}
\DisplayProof
\end{prooftree}

\begin{prooftree}
\RightLabel{T-App}
\AxiomC{$ \Gamma \,\vdash\,t_1:T_1_1 \to T_1_2 $}
\AxiomC{$ \Gamma \vdash t_2 : T_1_1 $}
\BinaryInfC{$ \Gamma \vdash t_1 t_2 : T_1_2 $}
\DisplayProof
\end{prooftree}
\end{block}
\end{column}
\end{columns}
\end{frame}
\begin{frame}[label={sec:orgbb7919b}]{Simply Typed Lambda Calculus}
\begin{columns}
\begin{column}[t]{0.45\columnwidth}
\begin{block}{Syntax}
\scriptsize

\begin{itemize}
\item[$t :=$] $x$
\item[] $\lambda x:T.t$
\item[] $t_1\,t_2$
\item[] $Z$
\item[] $S\,t$
\item[] $Case\,t_0\,of\,0 \to t_1\,|\, S m \to t_2$
\end{itemize}

\begin{itemize}
\item[$v :=$] $\lambda x:T.t$
\item[] $Z$
\item[] $S\,v$
\end{itemize}

\begin{itemize}
\item[$T :=$] $T \to T$
\item[] $Nat$
\end{itemize}

\begin{itemize}
\item[$\Gamma :=$] $\varnothing$
\item[] $\Gamma,\,x:T$
\end{itemize}
\end{block}
\end{column}
\begin{column}[t]{0.6\columnwidth}
\begin{block}{Evaluation}
\vspace{-10pt}
\scriptsize
\begin{prooftree}
\RightLabel{E-App1}
\AxiomC{$ t_1 \to t_1' $}
\UnaryInfC{$ t_1 t_2 \to t_1' t_2 $}
\DisplayProof
\end{prooftree}

\begin{prooftree}
\RightLabel{E-App2}
\AxiomC{$ t_2 \to t_2' $}
\UnaryInfC{$ v_1 t_2 \to v_1 t_2' $}
\DisplayProof
\end{prooftree}

\((\lambda x : T_1_1 . t_1_2)v_2 \to [x  \mapsto v_2]t_1_2\) E-AppAbs
\end{block}
\begin{block}{Typing}
\vspace{-10pt}
\scriptsize
\begin{prooftree}
\RightLabel{T-Var}
\AxiomC{$ x : T\,\in\,\Gamma $}
\UnaryInfC{$ \Gamma \vdash x : T $}
\DisplayProof
\end{prooftree}

\begin{prooftree}
\RightLabel{T-Abs}
\AxiomC{$ \Gamma,x : T_1\,\vdash\,t_2:T_2 $}
\UnaryInfC{$ \Gamma \vdash \lambda x : T_1.t_2 : T_1 \to T_2 $}
\DisplayProof
\end{prooftree}

\begin{prooftree}
\RightLabel{T-App}
\AxiomC{$ \Gamma \,\vdash\,t_1:T_1_1 \to T_1_2 $}
\AxiomC{$ \Gamma \vdash t_2 : T_1_1 $}
\BinaryInfC{$ \Gamma \vdash t_1 t_2 : T_1_2 $}
\DisplayProof
\end{prooftree}
\end{block}
\end{column}
\end{columns}
\end{frame}
\begin{frame}[label={sec:org08f09ea}]{New Evaluation Rules}
\begin{prooftree}
\RightLabel{\textbf{E-Succ}}
\AxiomC{$ t_1 \to t_1' $}
\UnaryInfC{$S\,t1'$}
\DisplayProof
\end{prooftree}
\begin{prooftree}
$(Case\,Z\,of$\,0 \to t_1\,|\,S\,m \to t_2) \longrightarrow t1$ \textbf{E-CaseZ}
\end{prooftree}
\begin{prooftree}
$(Case\,(S\,n)\,of\,0 \to t_1\,|\,S\,m \to t_2) \longrightarrow [m \mapsto n]t_2$ \textbf{E-CaseS}
\end{prooftree}
\begin{prooftree}
\RightLabel{\textbf{E-Case}}
\AxiomC{$ t_0 \to t_0' $}
\UnaryInfC{$(Case\,t_0\,of\,0 \to t_1\,|\, S\,m \to t_2)$}
\DisplayProof
 $\longrightarrow(Case\,t_0'\,of\,0 \to t_1\,|\, S\,m \to t_2)$
\end{prooftree}
\end{frame}
\begin{frame}[label={sec:org760e09d}]{New Typing Rules}
\begin{prooftree}
\RightLabel{T-NatZ}
\AxiomC{}
\UnaryInfC{$ Z:Nat $}
\DisplayProof
\end{prooftree}

\begin{prooftree}
\RightLabel{T-NatS}
\AxiomC{$ \Gamma \vdash t_1 : Nat $}
\UnaryInfC{$ S\, t_1 : Nat $}
\DisplayProof
\end{prooftree}

\begin{prooftree}
\RightLabel{T-Case}
\AxiomC{$ \Gamma\vdash \,t_0:Nat $}
\AxiomC{$ \Gamma\vdash \,t_1:T_1 $}
\AxiomC{$ \Gamma\vdash \,t_2:T_1 $}
\TrinaryInfC{$ \Gamma \vdash (Case\, t_0\, of\,0 \to t_1\,|\,(S\, m) \to t_2) : T_1 $}
\DisplayProof
\end{prooftree}
\end{frame}
\begin{frame}[label={sec:org36c6982}]{Typechecking}
\end{frame}
\begin{frame}[label={sec:orga185a3a}]{Implementation: Typechecker}
\end{frame}
\begin{frame}[label={sec:org7bb0eaa}]{Implementation: Evaluator}
\end{frame}
\begin{frame}[label={sec:orgca6c433}]{Thank You!}
\end{frame}
\end{document}
